// Generated by CoffeeScript 1.7.1
"use strict";
var Playlist, PlaylistSchema, Session, SessionSchema, User, UserSchema, Video, VideoSchema, YoutubeVideo, async, bcrypt, config, mongoose, parsers, util, _;

mongoose = require('mongoose');

parsers = require('./parsers');

util = require('util');

config = require('./config');

async = require('async');

bcrypt = require('bcrypt-nodejs');

_ = require('underscore');

YoutubeVideo = parsers.YoutubeVideo;

SessionSchema = mongoose.Schema({
  sid: String,
  session: Object
});

Session = mongoose.model('Session', SessionSchema);

UserSchema = mongoose.Schema({
  roles: {
    type: Array,
    "default": ['user']
  },
  username: String,
  isAccountNonExpired: {
    type: Boolean,
    "default": true
  },
  isEnabled: {
    type: Boolean,
    "default": true
  },
  isCredentialsNonExpired: {
    type: Boolean,
    "default": true
  },
  isAccountNonLocked: {
    type: Boolean,
    "default": true
  },
  local: {
    email: String,
    password: String
  },
  facebook: {
    id: String,
    token: String,
    email: String,
    name: String
  },
  twitter: {
    id: String,
    token: String,
    displayName: String,
    username: String
  },
  google: {
    id: String,
    token: String,
    email: String,
    name: String
  }
});


/* Hash generation */

UserSchema.methods.generateHash = function(password) {
  return bcrypt.hashSync(password, bcrypt.genSaltSync(8), null);
};


/* check password */

UserSchema.methods.validPassword = function(password) {
  return bcrypt.compareSync(password, this.local.password);
};

UserSchema.methods.toString = function() {
  return this.username.toString();
};

User = mongoose.model('User', UserSchema);

VideoSchema = mongoose.Schema({
  url: {
    type: String
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  title: String,
  description: String,
  "private": {
    type: Boolean,
    "default": false
  },
  categoryId: Number,
  duration: Object,
  created_at: {
    type: Date,
    'default': Date.now
  },
  updated_at: {
    type: Date,
    'default': Date.now
  },
  publishedAt: {
    type: Date,
    'default': Date.now
  },
  originalId: String,
  provider: String,
  thumbnail: String,
  meta: Object,
  viewCount: {
    type: Number,
    "default": 0
  }
});


/* create video from video url */

VideoSchema.statics.fromUrl = function(url, callback) {
  var youtubeVideo;
  youtubeVideo = new YoutubeVideo(config.youtube_apikey);
  if (youtubeVideo.isValidUrl(url)) {
    return youtubeVideo.getVideoDataFromUrl(url, function(err, res) {
      var video;
      if (err) {
        return callback(new Error(util.format("Video with url %s not found", url)));
      } else {
        video = new Video(res);
        return video.save(callback);
      }
    });
  } else {
    return callback(new Error(util.format("Video with url %s not found", url)));
  }
};

VideoSchema.statics.findByOwnerId = function(id, cb) {
  var q;
  q = this.find({
    owner: id
  });
  if (cb) {
    return q.exec(cb);
  } else {
    return q;
  }
};

VideoSchema.statics.list = function(query, callback) {
  var q;
  if (query instanceof Function) {
    callback = query;
    query = {};
  }
  q = this.find(query).select('title thumbnail created_at owner').sort({
    created_at: -1
  }).populate('owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

VideoSchema.statics.findPublicVideos = function(where, callback) {
  var q;
  if (where == null) {
    where = {};
  }
  if (where instanceof Function) {
    callback = where;
    where = {};
  }
  where = _.extend(where, {
    "private": false
  });
  q = this.find(where).limit(40).sort({
    created_at: -1
  }).populate('owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

VideoSchema.methods.toString = function() {
  return this.title;
};


/*
 * find Similar 
 * @param  {Video}   video   
 * @param  {Object}   options  
 * @param  {Function} callback
 */

VideoSchema.statics.findSimilar = function(video, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  }
  return this.find({
    categoryId: video.categoryId,
    _id: {
      '$ne': video.id
    }
  }, null, options, function(err, res) {
    return callback(err, res);
  });
};

Video = mongoose.model('Video', VideoSchema);

PlaylistSchema = mongoose.Schema({
  title: {
    type: String,
    required: true
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  thumbnail: {
    type: String
  },
  description: String,
  videos: [
    {
      ref: 'Video',
      type: mongoose.Schema.Types.ObjectId
    }
  ],
  video_urls: String,
  "private": {
    type: Boolean,
    "default": false
  }
});

PlaylistSchema.pre('save', function(next) {
  var self, _urls;
  self = this;

  /* transform a list of video urls into video documents and add video ids to video field */
  if (this.video_urls) {
    _urls = this.video_urls;
    this.video_urls = void 0;
    return async.map(_urls.split(/\s+/), function(url, next) {
      return Video.fromUrl(url, function(err, video) {
        return next(null, video);
      });
    }, (function(err, videos) {
      var ids;
      if (videos) {
        ids = _.pluck(videos, '_id');
        self.videos = _.isArray(self.videos) ? self.videos.concat(ids) : ids;
        if (videos.length > 0) {
          self.thumbnail = videos[0].thumbnail;
        }
      }
      return next();
    }));
  } else {
    return next();
  }
});

PlaylistSchema.statics.findByOwnerId = function(id, callback) {
  var q;
  q = this.find({
    owner: id
  }).populate('videos owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

Playlist = mongoose.model('Playlist', PlaylistSchema);

module.exports = mongoose;

//# sourceMappingURL=database.map
