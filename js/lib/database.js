// Generated by CoffeeScript 1.7.1
"use strict";
var Category, CategorySchema, Playlist, PlaylistSchema, Session, SessionSchema, User, UserSchema, Video, VideoSchema, YoutubeVideo, async, bcrypt, config, mongoose, parsers, q, util, _;

mongoose = require('mongoose');

parsers = require('./parsers');

util = require('util');

config = require('./config');

async = require('async');

bcrypt = require('bcrypt-nodejs');

_ = require('lodash');

q = require('q');

YoutubeVideo = parsers.YoutubeVideo;

SessionSchema = mongoose.Schema({
  sid: String,
  session: Object
});

Session = mongoose.model('Session', SessionSchema);


/*
 * USER
 */

UserSchema = mongoose.Schema({
  roles: {
    type: Array,
    "default": ['user']
  },
  username: String,
  isAccountNonExpired: {
    type: Boolean,
    "default": true
  },
  isEnabled: {
    type: Boolean,
    "default": true
  },
  isCredentialsNonExpired: {
    type: Boolean,
    "default": true
  },
  isAccountNonLocked: {
    type: Boolean,
    "default": true
  },
  local: {
    email: String,
    password: String
  },
  facebook: {
    id: String,
    token: String,
    email: String,
    name: String
  },
  twitter: {
    id: String,
    token: String,
    displayName: String,
    username: String
  },
  google: {
    id: String,
    token: String,
    email: String,
    name: String
  }
});


/* Hash generation */

UserSchema.methods.generateHash = function(password) {
  return bcrypt.hashSync(password, bcrypt.genSaltSync(8), null);
};


/* check password */

UserSchema.methods.validPassword = function(password) {
  return bcrypt.compareSync(password, this.local.password);
};

UserSchema.methods.toString = function() {
  return this.username.toString();
};

User = mongoose.model('User', UserSchema);


/*
 * CATEGORY
 */

CategorySchema = mongoose.Schema({
  title: {
    type: String,
    required: 'title is required'
  },
  provider: {
    type: String,
    "default": "youtube"
  },
  originalId: Number
});


/*
 * @return Promise<Array>
 * @TODO implement
 */

CategorySchema.statics.whereVideoExist = function() {
  return q.ninvoke(Video, 'aggregate', [
    {
      $match: {
        category: {
          $exists: true
        }
      }
    }, {
      $group: {
        _id: "$category",
        total: {
          $sum: 1
        }
      }
    }
  ]).then(function(categories) {
    return Category.find({
      _id: {
        $in: _.pluck(categories, '_id')
      }
    }).exec();
  });
};

CategorySchema.methods.toString = function() {
  return this.title;
};

Category = mongoose.model('Category', CategorySchema);


/*
 * VIDEO
 */

VideoSchema = mongoose.Schema({
  url: {
    type: String
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  title: {
    type: String,
    required: "title is required"
  },
  description: {
    type: String
  },
  "private": {
    type: Boolean,
    "default": false
  },
  categoryId: Number,
  category: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Category'
  },
  duration: Object,
  created_at: {
    type: Date,
    'default': Date.now
  },
  updated_at: {
    type: Date,
    'default': Date.now
  },
  publishedAt: {
    type: Date,
    'default': Date.now
  },
  originalId: String,
  provider: String,
  thumbnail: String,
  meta: Object,
  viewCount: {
    type: Number,
    "default": 0
  }
});


/* 
    create video from video url 
    if document already exist,return existing video
    @param url
    @param properties?
    @param {Function} callback
 */

VideoSchema.statics.fromUrl = function(url, properties, callback) {
  var youtubeVideo;
  if (properties == null) {
    properties = {};
  }
  if (arguments.length === 2 && properties instanceof Function) {
    callback = properties;
    properties = {};
  }
  youtubeVideo = new YoutubeVideo(config.youtube_apikey);
  if (youtubeVideo.isValidUrl(url)) {
    return youtubeVideo.getVideoDataFromUrl(url, function(err, data) {
      if (err) {
        return callback(err);
      } else {
        _.extend(data, properties);
        return Video.findOne({
          owner: data.owner,
          url: data.url
        }, function(err, video) {
          if (err) {
            return callback(err);
          } else if (video) {
            return callback(null, video);
          } else {
            return (new Video(data)).save(callback);
          }
        });
      }
    });
  } else {
    return callback(new Error(util.format("Video with url %s not found", url)));
  }
};

VideoSchema.statics.findByOwnerId = function(id, cb) {
  var query;
  query = this.find({
    owner: id
  });
  if (cb) {
    return query.exec(cb);
  } else {
    return query;
  }
};

VideoSchema.statics.list = function(query, callback, q) {
  if (query instanceof Function) {
    callback = query;
    query = {};
  }
  q = this.find(query).select('title thumbnail created_at owner').sort({
    created_at: -1
  }).populate('owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

VideoSchema.statics.findPublicVideos = function(where, callback, q) {
  if (where == null) {
    where = {};
  }
  if (where instanceof Function) {
    callback = where;
    where = {};
  }
  where = _.extend(where, {
    "private": false
  });
  q = this.find(where).limit(40).sort({
    updated_at: -1
  }).populate('owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

VideoSchema.methods.toString = function() {
  return this.title;
};


/*
 * find Similar 
 * @param  {Video}   video   
 * @param  {Object}   options  
 * @param  {Function} callback
 */

VideoSchema.statics.findSimilar = function(video, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  }
  return this.find({
    categoryId: video.categoryId,
    _id: {
      '$ne': video.id
    }
  }, null, options, function(err, res) {
    return callback(err, res);
  });
};

VideoSchema.pre('save', function(next) {
  this.updated_at = Date.now();
  if (!this.category && this.categoryId) {
    return Category.findOne({
      originalId: this.categoryId
    }).exec().then(((function(_this) {
      return function(category) {
        _this.category = category;
        return next();
      };
    })(this)), function() {
      return next();
    });
  } else {
    return next();
  }
});

Video = mongoose.model('Video', VideoSchema);

PlaylistSchema = mongoose.Schema({
  title: {
    type: String,
    required: true
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  thumbnail: {
    type: String
  },
  description: String,
  videos: [
    {
      ref: 'Video',
      type: mongoose.Schema.Types.ObjectId
    }
  ],
  video_urls: String,
  "private": {
    type: Boolean,
    "default": false
  }
});

PlaylistSchema.pre('save', function(next) {

  /* transform a list of video urls into video documents and add video ids to video field */
  var _props, _urls;
  if (typeof this.video_urls === "string") {
    _urls = _.compact(this.video_urls.split(/[\s \n \r ,]+/));
    _props = this.owner ? {
      owner: this.owner
    } : {};
    return async.map(_urls, (function(_this) {
      return function(url, next) {
        return Video.fromUrl(url, _props, function(err, video) {
          console.warn(err);
          return next(null, video);
        });
      };
    })(this), ((function(_this) {
      return function(err, videos) {
        var _ref;
        if (videos == null) {
          videos = [];
        }
        _this.videos = videos;
        _this.thumbnail = (_ref = videos[0]) != null ? _ref.thumbnail : void 0;
        return next();
      };
    })(this)));
  } else {
    return next();
  }
});

PlaylistSchema.statics.findByOwnerId = function(id, callback, q) {
  q = this.find({
    owner: id
  }).populate('videos owner');
  if (callback) {
    return q.exec(callback);
  } else {
    return q;
  }
};

PlaylistSchema.methods.toString = function() {
  return this.title;
};

PlaylistSchema.methods.getFirstVideo = function() {
  return this.videos[0];
};

Playlist = mongoose.model('Playlist', PlaylistSchema);

module.exports = mongoose;

//# sourceMappingURL=database.map
