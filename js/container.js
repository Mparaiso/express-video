// Generated by CoffeeScript 1.7.1
"use strict";
var Pimple, container,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Pimple = require('pimple');

container = new Pimple({
  port: process.env.OPENSHIFT_NODEJS_PORT || process.env.PORT || 3000,
  ip: process.env.OPENSHIFT_NODEJS_IP,
  youtub_api_key: process.env.EXPRESS_VIDEO_YOUTUBE_API_KEY,
  connection_string: process.env.EXPRESS_VIDEO_MONGODB_CONNECTION_STRING,
  debug: process.env.NODE_ENV === "production" ? false : true,
  item_per_page: 26
});

container.register(require('./database'));

container.register(require('./controllers'));

container.register(require('./middlewares'));

container.register(require('./forms'));

container.register(require('./players'));

container.register(require('./validation'));

container.register(require('./app'));

container.set("parsers", container.share(function() {
  return require('./parsers');
}));

container.set("config", container.share(function() {
  return require('./config');
}));

container.set("express", container.share(function() {
  return require('express');
}));

container.set('_', container.share(function() {
  return require('lodash');
}));

container.set('path', container.share(function() {
  return require('path');
}));

container.set('q', container.share(function(c) {
  var q;
  q = require('q');
  if (c.debug) {
    q.longStackSupport = true;
  }
  return q;
}));

container.set('acl', container.share(function(c) {
  var Acl, acl;
  Acl = require('virgen-acl');
  return acl = new Acl;
}));

container.set("locals", container.share(function() {
  return {
    title: "videopress",
    logopath: "/images/video-big.png",
    paginate: function(array, length, start) {
      var divisions, _i, _results;
      if (start == null) {
        start = 0;
      }
      divisions = Math.ceil(array.length / length);
      return (function() {
        _results = [];
        for (var _i = start; start <= divisions ? _i < divisions : _i > divisions; start <= divisions ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(i) {
        return array.slice(i * length, i * length + length);
      });
    }
  };
}));

container.set("swig", container.share(function(c) {
  var swig;
  swig = require('swig');
  swig.setDefaults({
    cache: c.debug ? false : "memory"
  });
  return swig;
}));

container.set("sessionStore", container.share(function() {
  var sessionStores;
  sessionStores = require('./session-stores');
  return new sessionStores.MongooseSessionStore({}, container.Session);
}));

container.set("videoParser", container.share(function(c) {
  var dailymotionParser, videoParserChain, vimeoVideoParser, youtubeShortParser, youtubeVideoParser;
  youtubeVideoParser = new c.parsers.Youtube(c.config.youtube_apikey);
  youtubeShortParser = new c.parsers.YoutubeShort(c.config.youtube_apikey);
  vimeoVideoParser = new c.parsers.Vimeo(c.config.vimeo_access_token);
  dailymotionParser = new c.parsers.Dailymotion();
  videoParserChain = new c.parsers.Chain([youtubeVideoParser, vimeoVideoParser, dailymotionParser, youtubeShortParser]);
  return videoParserChain;
}));

container.set("playlistParser", container.share(function(c) {
  return new c.parsers.Chain([new c.parsers.YoutubePlaylist(c.config.youtube_apikey, c.q, c._)]);
}));

container.set("passport", container.share(function() {
  var LocalStrategy, User, passport;
  passport = require('passport');
  LocalStrategy = require('passport-local').Strategy;
  User = container.User;
  passport.serializeUser(function(user, done) {
    return done(null, user.id);
  });
  passport.deserializeUser(function(id, done) {
    return User.findById(id, done);
  });
  passport.use('local-signup', new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  }, function(req, email, password, done) {
    return process.nextTick(function() {
      return User.findOne({
        'local.email': email
      }, function(err, user) {
        var newUser;
        if (err) {
          done(err);
        }
        if (user) {
          return done(null, false, req.flash('signupMessage', 'That email is already taken'));
        } else {
          newUser = new User();
          newUser.username = req.body.username;
          newUser.local.email = email;
          newUser.local.password = newUser.generateHash(password);
          return newUser.save(done);
        }
      });
    });
  }));
  passport.use('local-login', new LocalStrategy({
    usernameField: 'email',
    passwordField: 'password',
    passReqToCallback: true
  }, function(req, email, password, done) {
    return User.findOne({
      'local.email': email
    }, function(err, user) {
      if (err) {
        return done(err);
      }
      if (user) {
        if (user.validPassword(password)) {
          return done(null, user);
        }
      }
      return done(null, false, req.flash('loginMessage', 'Invalid credentials!'));
    });
  }));
  return passport;
}));

container.set("playerFactory", container.share(function(c) {
  return new c.players.PlayerFactory([c.players.Youtube, c.players.Vimeo, c.players.Dailymotion]);
}));

container.set("errors", container.share(function() {
  return {
    NotFound: (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        _Class.__super__.constructor.apply(this, arguments);
        this.status = 404;
      }

      return _Class;

    })(Error),
    Forbidden: (function(_super) {
      __extends(_Class, _super);

      function _Class() {
        _Class.__super__.constructor.apply(this, arguments);
        this.status = 500;
      }

      return _Class;

    })(Error)
  };
}));

container.set("monolog", container.share(function() {
  return require('monolog');
}));

container.set("logger", container.share(function(c) {
  var Logger, logger, monolog;
  monolog = c.monolog;
  Logger = monolog.Logger;
  logger = new Logger("express logger");
  logger.addHandler(new monolog.handler.StreamHandler(__dirname + "/../temp/log.txt", Logger.DEBUG));
  logger.addHandler(new monolog.handler.ConsoleLogHandler(Logger.INFO));
  logger.addHandler(new c.MongooseLogHandler(c.Log, Logger.INFO));
  return logger;
}));

container.set("MongooseLogHandler", container.share(function(c) {
  var MongooseLogHandler;
  return MongooseLogHandler = (function(_super) {
    __extends(MongooseLogHandler, _super);

    function MongooseLogHandler(mongooseModel, level, bubble) {
      this.mongooseModel = mongooseModel;
      if (level == null) {
        level = 100;
      }
      if (bubble == null) {
        bubble = true;
      }
      MongooseLogHandler.__super__.constructor.call(this, level, bubble);
    }


    /*
     * @param record
     * @param {Function} cb
     */

    MongooseLogHandler.prototype.write = function(record, cb) {
      this.mongooseModel.create(record, (function(_this) {
        return function(err, res) {
          return cb(err, res, record, _this);
        };
      })(this));
      return this.bubble;
    };

    return MongooseLogHandler;

  })(c.monolog.handler.AbstractProcessingHandler);
}));

module.exports = container;

//# sourceMappingURL=container.map
